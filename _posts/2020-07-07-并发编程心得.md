
单线程里面的某个操作如果不满足先验条件，程序就只能直接失败。

多线程里，即使某个操作不满足先验条件也是没关系的，可能经过其它线程对资源的修改，当前线程突然就能通过先验条件了；所以，多线程程序里，遇到先验条件要停住等待，直到先验条件为真。

你看到的false不一定是真的false，这从表象来看是有点”玄学“，但从底层看一切都很合理。

等待（等待某个条件为真）和通知机制属于内置机制，它们都跟内置加锁机制密切相关。Blocking Queue（阻塞队列）或信号量（semaphore）这个时候就非常有用了，它们可以帮助实现依赖状态的行为。

## 状态的所有权
容器类”所有权分离“，容器类拥有自身的状态，而客户代码拥有容器中各个对象的状态。因此，ServletContext接口的实现类必须是线程安全的。
我们应用程序代码可以setAttribute(name, obj)和getAttribute(name)来注册和获取应用程序对象，这时不需要使用同步，因为这些应用程序对象是ServletContext的状态field，而ServletContext本身设计得就是线程安全的。
但当我们想要访问保存在ServletContext的对象时，必须使用同步，因为这些对象由应用程序拥有，可能会出现跟我们同等地位的线程并发地访问这些对象的情况。

## Vector 分析
Vector是一种并发安全的”动态自动扩缩容数组“实现，它的缺点很明显：由于过多地在方法层级使用 synchronize 关键字来保证同步访问共享资源，它的活跃性是很差的。

## CopyOnWriteArrayList 分析

CopyOnWriteArrayList的核心思想，所有改变状态的操作如add，set等都由制作基础数组的新副本来实现。就在源码注释的第一行！copy before write，见名思意，这种保证线程安全的开销特别大。

