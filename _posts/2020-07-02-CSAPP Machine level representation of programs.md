
## 机器码和它的反汇编 disassembly 表示

* x86-64 指令可能的长度范围从1到15个字节（不定长），常用指令和操作数较少的指令所需的字节数要比不那么常用的指令或操作数较多的指令少。

commonly used instructions and those with fewer operands require a smaller number of bytes than do less common ones or ones with more operands.



* 从给定起始位置开始，字节到机器指令只有一个唯一的解码（即机器指令以特殊字节开头）。比如，只有 **pushq %rbx** 能以字节值 53 开头。

* 相比gcc生成的汇编代码，反汇编器对指令使用了略微不同的命名转换（比如去掉操作数宽度后缀 pushq -> push）。

The disassembler uses a slightly different naming convention for the instructions than does the assembly code generated by gcc

## linker的作用

* 把全部代码的位置都切换成一个不同范围区间的地址，即 ”固定的默认占坑的地址“ -> ”真实的地址“

shifted the location of this code to a different range of addresses

* 把调用其它函数的（占坑的）引用地址替换成函数的可执行代码的真实位置

One task for the linker is to match function calls with the locations of the executable code for those functions.

* 把 nop 指令放到函数末尾，让不足16字节的函数代码增长达到16字节，提升内存读取性能

They（nop instruction） have been inserted to grow the code for the function to 16 bytes, enabling a better placement of the next block of code in terms of memory system performance.

