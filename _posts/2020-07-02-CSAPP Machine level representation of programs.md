
## 机器码和它的反汇编 disassembly 表示

第二章”信息的表示和处理“，补码和有符号数相关的部分，超级绕脑的，公式也很多，看得头痛，但又是后面章节的基础，不可跳过。第三章就友好很多了，分析汇编指令和二进制更形象具体可操作。只要代码写得足够多，有了”直觉“，回头再看剖析代码底层逻辑的基础书籍，就会有种想法：<这个地方天然就应该是这样的>，丝毫不觉得这是阻碍。想起一句名言，”我们不是学会了数学，我们只是逐渐变得习惯了它”。

* x86-64 指令可能的长度范围从1到15个字节（不定长），常用指令和操作数较少的指令所需的字节数要比不那么常用的指令或操作数较多的指令少。

commonly used instructions and those with fewer operands require a smaller number of bytes than do less common ones or ones with more operands.



* 从给定起始位置开始，字节到机器指令只有一个唯一的解码（即机器指令以特殊字节开头）。比如，只有 **pushq %rbx** 能以字节值 53 开头。

* 相比gcc生成的汇编代码，反汇编器对指令使用了略微不同的命名转换（比如去掉操作数宽度后缀 pushq -> push）。

The disassembler uses a slightly different naming convention for the instructions than does the assembly code generated by gcc

## linker的作用

* 把全部代码的位置都切换成一个不同范围区间的地址，即 ”固定的默认占坑的地址“ -> ”真实的地址“

shifted the location of this code to a different range of addresses

* 把调用其它函数的（占坑的）引用地址替换成函数的可执行代码的真实位置

One task for the linker is to match function calls with the locations of the executable code for those functions.

* 把 nop 指令放到函数末尾，让不足16字节的函数代码增长达到16字节，提升内存读取性能

They（nop instruction） have been inserted to grow the code for the function to 16 bytes, enabling a better placement of the next block of code in terms of memory system performance.

